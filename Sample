stages:
  - build
  - deploy

variables:
  IMAGE_TAG: "$CI_REGISTRY_IMAGE/airflow:$CI_COMMIT_SHORT_SHA"
  PUSH_REGISTRY: "false"

# -------------- Windows build job (for Windows shell executor with Docker installed) --------------
build-airflow-image-windows:
  stage: build
  tags: ["local"]        # your Windows runner tag
  script:
    - powershell -NoProfile -Command "
        Write-Host 'Running on Windows runner - building with host Docker...';
        if (-not (Get-Command docker -ErrorAction SilentlyContinue)) { throw 'docker CLI not found on runner. Install Docker Desktop or ensure docker is in PATH.' };
        Write-Host 'Building image: $env:IMAGE_TAG';
        docker build -t $env:IMAGE_TAG .;
        if ($LASTEXITCODE -ne 0) { throw 'docker build failed' };
        Write-Host 'Saving image to image.tar';
        docker save -o image.tar $env:IMAGE_TAG;
        if (-not (Test-Path -Path image.tar)) { throw 'image.tar not created' };
        if ($env:PUSH_REGISTRY -eq 'true') {
          Write-Host 'Pushing to registry (optional)';
          docker login -u $env:CI_REGISTRY_USER -p $env:CI_REGISTRY_PASSWORD $env:CI_REGISTRY;
          docker push $env:IMAGE_TAG;
        }
      "
  artifacts:
    paths:
      - image.tar
    expire_in: 1h
    reports:
      dotenv:
        - build.env
  after_script:
    - echo IMAGE_TAG="$IMAGE_TAG" > build.env


# Deploy to Minikube (Windows runner with PowerShell)
deploy-minikube:
  stage: deploy
  tags: ["local"]   # your Windows runner tag
  needs: ["build-airflow-image"]
  script:
    - |
      # ----- Prepare kubeconfig (PowerShell) -----
      if (-not $Env:KUBE_CONFIG) { throw "KUBE_CONFIG is missing (base64 kubeconfig)." }
      [IO.File]::WriteAllBytes("$PWD/kubeconfig.yaml", [Convert]::FromBase64String($Env:KUBE_CONFIG))
      $Env:KUBECONFIG = "$PWD/kubeconfig.yaml"
      kubectl version --client
      kubectl config get-contexts
      kubectl config use-context $Env:KUBE_CONTEXT

    - |
      # ----- Ensure namespace -----
      Write-Host "Ensuring namespace $($Env:KUBE_NAMESPACE) exists..."
      kubectl get ns $Env:KUBE_NAMESPACE 2>$null
      if ($LASTEXITCODE -ne 0) { kubectl create ns $Env:KUBE_NAMESPACE }

    - |
      # ----- Apply manifests -----
      kubectl apply -n $Env:KUBE_NAMESPACE -f "k8s/postgres-pvc.yaml"
      kubectl apply -n $Env:KUBE_NAMESPACE -f "k8s/postgres-deployment.yaml"
      kubectl apply -n $Env:KUBE_NAMESPACE -f "k8s/postgres-service.yaml"
      kubectl apply -n $Env:KUBE_NAMESPACE -f "k8s/airflow-config.yaml"
      kubectl apply -n $Env:KUBE_NAMESPACE -f "k8s/airflow-deployment.yaml"
      kubectl apply -n $Env:KUBE_NAMESPACE -f "k8s/airflow-scheduler.yaml"
      kubectl apply -n $Env:KUBE_NAMESPACE -f "k8s/airflow-service.yaml"

    - |
      # ----- Load image into Minikube (PowerShell) -----
      # The build job produced 'image.tar' as an artifact (docker save).
      # Try direct minikube load by name; if that fails, load from the tarball.
      Write-Host "Attempting to load image into minikube: $Env:IMAGE_TAG"
      # first try (preferred) - if Minikube can access docker/socket on runner (may work if same host)
      $try1 = Start-Process -FilePath "minikube" -ArgumentList @("image","load",$Env:IMAGE_TAG) -NoNewWindow -PassThru -Wait -ErrorAction SilentlyContinue
      if ($try1 -and $try1.ExitCode -eq 0) {
        Write-Host "Loaded image by name into minikube."
      } else {
        Write-Host "Falling back to loading image from tar artifact (image.tar)..."
        # Ensure artifact exists
        if (-Not (Test-Path -Path "$PWD\image.tar")) { throw "image.tar missing - build job artifact not found." }
        $try2 = Start-Process -FilePath "minikube" -ArgumentList @("image","load","--input","image.tar") -NoNewWindow -PassThru -Wait -ErrorAction SilentlyContinue
        if ($try2.ExitCode -ne 0) { Write-Warning "minikube image load --input image.tar failed (ExitCode $($try2.ExitCode))." }
      }

    - |
      # ----- Update deployments to refer to the image tag (optional, but keeps manifests consistent) -----
      Write-Host "Updating images to $($Env:IMAGE_TAG) ..."
      # Ensure container names are correct in your manifests; adjust container-name if necessary
      kubectl -n $Env:KUBE_NAMESPACE set image deploy/airflow-web airflow-web=$Env:IMAGE_TAG --record || Write-Warning "set image for airflow-web failed - check container name"
      kubectl -n $Env:KUBE_NAMESPACE set image deploy/airflow-scheduler scheduler=$Env:IMAGE_TAG --record || Write-Warning "set image for airflow-scheduler failed - check container name"

    - |
      # ----- Wait for rollout (PowerShell-safe) -----
      Write-Host "Waiting for airflow-web rollout..."
      $p = Start-Process -FilePath "kubectl" -ArgumentList @("rollout","status","deploy/airflow-web","-n",$Env:KUBE_NAMESPACE,"--timeout=300s") -NoNewWindow -PassThru -Wait
      if ($p.ExitCode -ne 0) { Write-Warning "airflow-web rollout timed out or failed, continuing..." }

      Write-Host "Waiting for airflow-scheduler rollout..."
      $p = Start-Process -FilePath "kubectl" -ArgumentList @("rollout","status","deploy/airflow-scheduler","-n",$Env:KUBE_NAMESPACE,"--timeout=300s") -NoNewWindow -PassThru -Wait
      if ($p.ExitCode -ne 0) { Write-Warning "airflow-scheduler rollout timed out or failed, continuing..." }

    - kubectl get pods -n $Env:KUBE_NAMESPACE -o wide
    - kubectl get svc  -n $Env:KUBE_NAMESPACE

  artifacts:
    when: on_failure
    paths:
      - ./*.log
