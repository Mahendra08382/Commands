stages:
  - build
  - deploy

variables:
  KUBE_NAMESPACE: "airflow"
  KUBE_CONTEXT: "minikube"
  IMAGE_TAG: "$CI_REGISTRY_IMAGE/airflow:$CI_COMMIT_SHORT_SHA"

build-airflow-image:
  stage: build
  image: docker:24.0.9
  services:
    - docker:24.0.9-dind
  variables:
    DOCKER_DRIVER: overlay2
  script:
    - echo "Building local image $IMAGE_TAG ..."
    - docker build -t "$IMAGE_TAG" .
    # Optional: skip push if you don't need registry
    - echo "Skipping push, using minikube preload"

deploy-minikube:
  stage: deploy
  tags: ["local"]   # self-hosted runner tag
  needs: ["build-airflow-image"]
  script:
    # ----- Decode kubeconfig -----
    - |
      if (-not $Env:KUBE_CONFIG) { throw "KUBE_CONFIG is missing (base64 kubeconfig)." }
      [IO.File]::WriteAllBytes("$PWD/kubeconfig.yaml", [Convert]::FromBase64String($Env:KUBE_CONFIG))
      $Env:KUBECONFIG = "$PWD/kubeconfig.yaml"
      kubectl version --client
      kubectl config get-contexts
      kubectl config use-context $Env:KUBE_CONTEXT

    # ----- Ensure namespace -----
    - |
      Write-Host "Ensuring namespace $($Env:KUBE_NAMESPACE) exists..."
      kubectl get ns $Env:KUBE_NAMESPACE 2>$null
      if ($LASTEXITCODE -ne 0) { kubectl create ns $Env:KUBE_NAMESPACE }

    # ----- Preload image into Minikube -----
    - |
      Write-Host "Preloading image $($Env:IMAGE_TAG) into minikube..."
      minikube image load $Env:IMAGE_TAG

    # ----- Apply manifests (ensure imagePullPolicy: IfNotPresent in YAML) -----
    - kubectl apply -n $Env:KUBE_NAMESPACE -f "k8s/postgres-pvc.yaml"
    - kubectl apply -n $Env:KUBE_NAMESPACE -f "k8s/postgres-deployment.yaml"
    - kubectl apply -n $Env:KUBE_NAMESPACE -f "k8s/postgres-service.yaml"
    - kubectl apply -n $Env:KUBE_NAMESPACE -f "k8s/airflow-config.yaml"
    - kubectl apply -n $Env:KUBE_NAMESPACE -f "k8s/airflow-deployment.yaml"
    - kubectl apply -n $Env:KUBE_NAMESPACE -f "k8s/airflow-scheduler.yaml"
    - kubectl apply -n $Env:KUBE_NAMESPACE -f "k8s/airflow-service.yaml"

    # ----- Point deployments to the new image -----
    - |
      Write-Host "Updating deployments to use preloaded image $($Env:IMAGE_TAG)..."
      kubectl -n $Env:KUBE_NAMESPACE set image deploy/airflow-web webserver=$Env:IMAGE_TAG --record
      kubectl -n $Env:KUBE_NAMESPACE set image deploy/airflow-scheduler scheduler=$Env:IMAGE_TAG --record

    # ----- Secrets and env injection (unchanged) -----
    # ... your Snowflake secret creation + kubectl set env remains here ...

    # ----- Rollout checks -----
    - |
      kubectl rollout status deploy/airflow-web -n $Env:KUBE_NAMESPACE --timeout=300s || echo "airflow-web rollout failed"
      kubectl rollout status deploy/airflow-scheduler -n $Env:KUBE_NAMESPACE --timeout=300s || echo "airflow-scheduler rollout failed"

    # ----- Summary -----
    - kubectl get pods -n $Env:KUBE_NAMESPACE -o wide
    - kubectl get svc  -n $Env:KUBE_NAMESPACE
